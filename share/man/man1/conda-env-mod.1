.\" Automatically generated by Pandoc 1.19.2.1
.\"
.TH "CONDA\-ENV\-MOD" "1" "" "Version 1.0" "Custom Anaconda environment management"
.hy
.SH NAME
.PP
\f[B]conda\-env\-mod\f[] \-\- Create and configure a custom Anaconda
environment for installing Python packages.
.SH SYNOPSIS
.PP
\f[B]conda\-env\-mod\f[] \f[B]subcommand\f[] [\f[B]argument(s)\f[]]
.PD 0
.P
.PD
\f[B]conda\-env\-mod\f[] [\f[B]\-h\f[]|\f[B]\-\-help\f[]]
.SH DESCRIPTION
.PP
This script makes very minimal Anaconda environments and generates Lmod
module files for using them.
Users can later install and use Python packages in the environment after
loading the modules.
.SS Key points:
.IP \[bu] 2
no need to \f[I]\[aq]source\ activate\[aq]\f[] or
\f[I]\[aq]conda\ activate\[aq]\f[] (csh/tcsh users, rejoice!)
.IP \[bu] 2
all users do is a familiar \f[I]\[aq]module\ use\[aq]\f[] and
\f[I]\[aq]module\ load/unload\[aq]\f[]
.IP \[bu] 2
generated environments have access to all packages of base Anaconda (but
users can also install their extras into environment)
.IP \[bu] 2
no more permission errors when Google tells user to do a
\f[I]\[aq]pip\ install\[aq]\f[]
.IP \[bu] 2
sane Jupyter kernels
.SH USAGE
.PP
\f[B]conda\-env\-mod\f[] \f[I]subcommand\f[] \f[I][...arguments...]\f[]
.PD 0
.P
.PD
\f[B]conda\-env\-mod\f[] \f[B]create\f[] [\f[B]\-n\f[]
\f[I]env_name\f[]|\f[B]\-p\f[] \f[I]env_path\f[]] [\f[B]\-m\f[]
\f[I]module_dir\f[]]
.PD 0
.P
.PD
\f[B]conda\-env\-mod\f[] \f[B]delete\f[] [\f[B]\-n\f[]
\f[I]env_name\f[]|\f[B]\-p\f[] \f[I]env_path\f[]] [\f[B]\-m\f[]
\f[I]module_dir\f[]]
.PD 0
.P
.PD
\f[B]conda\-env\-mod\f[] \f[B]module\f[] [\f[B]\-n\f[]
\f[I]env_name\f[]|\f[B]\-p\f[] \f[I]env_path\f[]] [\f[B]\-m\f[]
\f[I]module_dir\f[]]
.PD 0
.P
.PD
\f[B]conda\-env\-mod\f[] \f[B]kernel\f[] [\f[B]\-n\f[]
\f[I]env_name\f[]|\f[B]\-p\f[] \f[I]env_path\f[]]
.PD 0
.P
.PD
\f[B]conda\-env\-mod\f[] \f[B]help\f[]
.SH EXAMPLES
.PP
\f[I]conda\-env\-mod create \-n my_test\f[]
.PD 0
.P
.PD
\f[I]conda\-env\-mod create \-p /my/project/dir/my_test\f[]
.PD 0
.P
.PD
\f[I].....\f[]
.PD 0
.P
.PD
\f[I]module use $HOME/privatemodules\f[]
.PD 0
.P
.PD
\f[I]module load conda\-env/my_test\-py3.6.4\f[]
.PD 0
.P
.PD
\f[I]conda install ....\f[]
.PD 0
.P
.PD
\f[I]pip install ....\f[]
.SH SUBCOMMANDS
.TP
.B \f[B]create\f[]
Create an environment.
Must specify \f[I]env_name\f[] or \f[I]env_path\f[].
.RS
.RE
.TP
.B \f[B]delete\f[]
Delete an existing environment.
Must specify \f[I]env_name\f[] or \f[I]env_path\f[].
.RS
.RE
.TP
.B \f[B]module\f[]
Create a module file for an existing environment.
Must specify \f[I]env_name\f[] or \f[I]env_path\f[].
.RS
.RE
.TP
.B \f[B]kernel\f[]
Create a Jupyter kernel for an existing environment.
Must specify \f[I]env_name\f[] or \f[I]env_path\f[].
.RS
.RE
.TP
.B \f[B]help\f[]
Display brief usage information.
.RS
.RE
.SH ARGUMENTS
.SS Required (pick one):
.TP
.B \f[B]\-n\f[], \f[B]\-\-name\f[] \f[I]env_name\f[]
Name of the environment.
.RS
.RE
.TP
.B \f[B]\-p\f[], \f[B]\-\-prefix\f[] \f[I]env_path\f[]
Location of the environment.
.RS
.RE
.SS Optional:
.TP
.B \f[B]\-a\f[], \f[B]\-\-appname\f[] \f[I]app_name\f[]
Name of the module corresponding to the environment.
Default value is \f[I]\[aq]conda\-env\[aq]\f[].
.RS
.RE
.TP
.B \f[B]\-m\f[], \f[B]\-\-moduledir\f[] \f[I]module_dir\f[]
Location of the module file.
Default value is \f[I]$HOME/privatemodules\f[].
.RS
.RE
.TP
.B \f[B]\-y\f[], \f[B]\-\-yes\f[]
Assume \f[I]"yes"\f[] to all internal questions.
Default is to ask confirmations interactively.
.RS
.RE
.TP
.B \f[B]\-j\f[], \f[B]\-\-jupyter\f[]
When performing \f[B]"create"\f[] or \f[B]"module"\f[], also generate a
Jupyter kernel for this environment.
This option will also imply \f[I]\[aq]\-\-local\-python\[aq]\f[].
Default is to skip Jupyter kernel creation.
.RS
.RE
.TP
.B \f[B]\-\-local\-py\f[], \f[B]\-\-local\-python\f[], \f[B]\-\-add\-path\f[], \f[B]\-\-add\-to\-path\f[]
By default, generated modulefiles rely on Python interpreter from the
base Anaconda (new environment\[aq]s "bin" directory is \f[I]not\f[]
added to $PATH).
While this is intentional and often desired, for some occasions you
might need to do the opposite and use Python (and other commands) from
the new environment instead.
One notable use case is when creating a Jupyter kernel for new
environment, or occasionally when some of your desired packages conflict
with their counterparts in the base Anaconda.
Another use case may be when your packages generate additional
executables that you want to call from the command line.
This switch will tweak the generated modulefile to prepend
environment\[aq]s "bin" directory to the $PATH.
.RS
.RS
.PP
Note that if you go this route, base Anaconda packages become
unavailable, so you would have to install \f[I]all\f[] of your necessary
packages into the environment.
.RE
.RE
.SS To summarize:
.IP \[bu] 2
In default mode, resulting environment uses \f[I]base\f[] Python and all
of the base\[aq]s existing packages, while
\f[I]\[aq]pip\ install\[aq]\f[] and \f[I]\[aq]conda\ install\[aq]\f[]
conveniently install new packages into the environment.
.IP \[bu] 2
In the \f[B]\[aq]\-\-local\-python\[aq]\f[] mode, your resulting
environment uses the \f[I]environment\[aq]s\f[] Python, and does
\f[I]not\f[] see any of the base Anaconda packages.
So you would have to \f[I]\[aq]pip\ install\[aq]\f[] and
\f[I]\[aq]conda\ install\[aq]\f[] everything you need.
.IP \[bu] 2
No matter what mode, \f[B]do not use\f[]
\f[I]\[aq]pip\ install\ \-\-user\[aq]\f[] (you want your packages to go
into the environment, not into
\f[I]$HOME/.local/lib/pythonX.Y/site\-packages\f[]).
.PP
When generating Jupyter kernels (\f[B]"kernel"\f[] mode or
\f[B]\[aq]\-\-jupyter\[aq]\f[]), everything about
\f[B]\[aq]\-\-local\-python\[aq]\f[] above applies.
Additionally, we highly recommend installing your packages from the
command line.
\f[B]DO NOT USE\f[] plain \f[I]\[aq]!pip\ install\[aq]\f[] or
\f[I]\[aq]!conda\ install\[aq]\f[] from inside the Jupyter notebook! See
excellent explanation why here:
.PP
http://jakevdp.github.io/blog/2017/12/05/installing\-python\-packages\-from\-jupyter/
.PP
If you do need to install packages from inside a notebook, use either of
these calls in a cell:
.IP
.nf
\f[C]
!{sys.executable}\ \-m\ pip\ install\ .....
!conda\ install\ \-\-yes\ \-\-prefix\ {sys.prefix}\ .....
\f[]
.fi
.PP
The \f[I]\[aq]{sys.executable}\[aq]\f[] and
\f[I]\[aq]{sys.prefix}\[aq]\f[] tokens make sure that the kernel\[aq]s
own tools are used (and not ones from the separate JupyterHub
installation itself), so packages get installed in the right location
and remain visible for the kernel.
.SH OPTIONS
.TP
.B \f[B]\-h, \-\-help\f[]
Prints brief usage information.
.RS
.RE
.SH BUGS
.PP
No known bugs.
.PP
Please report issues on Github:
https://github.com/amaji/conda\-env\-mod/issues
.SH AUTHOR
.PP
Amiya K Maji and Lev Gorenstein, Purdue University
.SH SEE ALSO
.PP
\f[B]conda\-env\-mod(1)\f[], \f[B]conda\-env\f[]
.PP
A few sample use cases:
https://www.rcac.purdue.edu/knowledge/brown/run/examples/apps/python/packages
